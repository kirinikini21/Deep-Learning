# -*- coding: utf-8 -*-
"""231204_Image Colorization with U-Net and GAN -송해데이터.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1geHCpCk7ewRDwwOBpL4QRPYvs02t3271

# Image Colorization with U-Net and GAN Tutorial
"""

#Google Colab 환경에서 구글 드라이브를 마운트
from google.colab import drive
drive.mount('/content/drive')

"""**If you have already read the explanations, you can directly go to the code starting with heading: _1 - Implementing the paper - Our Baseline_**

![title image](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/main.png?raw=1)

One of the most exciting applications of deep learning is colorizing black and white images.  This task needed a lot of human input and hardcoding several years ago but now the whole process can be done end-to-end with the power of AI and deep learning. You might think that you need huge amount of data or long training times to train your model from scratch for this task but in the last few weeks I worked on this and tried many different model architectures, loss functions, training strategies, etc. and finally developed an efficient strategy to train such a model, using the latest advances in deep learning, on a rather small dataset and with really short training times. In this article, I'm going to explain what I did to make this happen, including the code!, and the strategies that helped and also those that were not useful. Before that, I will explain the colorization problem and a give you a short review of what has been done in recent years. I'll assume you have basic knowledge about deep learning, GANs, and PyTorch library for the rest of the article. Let's begin!

## Introduction to colorization problem

Here I'm going to give you some basic knowledge that you may need to understand what the models do in the following codes.

### RGB vs L\*a\*b

As you might know, when we load an image, we get a rank-3 (height, width, color) array with the last axis containing the color data for our image. These data represent color in RGB color space and there are 3 numbers for each pixel indicating how much Red, Green, and Blue the pixel is. In the following image you can see that in the left part of the "main image" (the leftmost image) we have blue color so in the blue channel of the image, that part has higher values and has turned dark.

![rgb image](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/rgb.jpg?raw=1)

In L\*a\*b color space, we have again three numbers for each pixel but these numbers have different meanings. The first number (channel), L, encodes the Lightness of each pixel and when we visualize this channel (the second image in the row below) it appears as a black and white image. The \*a and \*b channels encode how much green-red and yellow-blue each pixel is, respectively. In the following image you can see each channel of L\*a\*b color space separately.

![lab image](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/lab.jpg?raw=1)

In all papers I studied and all codes I checked out on colorization on GitHub, people use L\*a\*b color space instead of RGB to train the models. There are a couple of reasons for this choice but I'll give you an intuition of why we make this choice. To train a model for colorization, we should give it a grayscale image and hope that it will make it colorful. When using L\*a\*b, we can give the L channel to the model (which is the grayscale image) and want it to predict the other two channels (\*a, \*b) and after its prediction, we concatenate all the channels and we get our colorful image. But if you use RGB, you have to first convert your image to grayscale, feed the grayscale image to the model and hope it will predict 3 numbers for you which is a way more difficult and unstable task due to the many more possible combinations of 3 numbers compared to two numbers. If we assume we have 256 choices (in a 8-bit unsigned integer image this is the real number of choices) for each number, predicting the three numbers for each of the pixels is choosing between 256³ combinations which is more than 16 million choices, but when predicting two numbers we have about 65000 choices (actually, we are not going to wildly choose these numbers like a classification task and I just wrote these numbers to give you an intuition).

## How to solve the problem

During the last few years, many different solutions have been proposed to colorize images by using deep learning. [_**Colorful Image Colorization**_](https://arxiv.org/abs/1603.08511) paper approached the problem as a classification task and they also considered the uncertainty of this problem (e.x. a car in the image can take on many different and valid colors and we cannot be sure about any color for it); however, another paper approached the problem as a regression task (with some more tweaks!). There are pros and cons to each approach but in this article, we are going to use a different strategy.

### The strategy we are going to use

[_**Image-to-Image Translation with Conditional Adversarial Networks**_](https://arxiv.org/abs/1611.07004) paper, which you may know by the name pix2pix, proposed a general solution to many image-to-image tasks in deep learning which one of those was colorization. In this approach two losses are used: L1 loss, which makes it a regression task, and an adversarial (GAN) loss, which helps to solve the problem in an unsupervised manner (by assigning the outputs a number indicating how "real" they look!).

In this tutorial, I will first implement what the authors did in the paper and then I will introduce a whole new generator model and some tweaks in the strategy of training which significantly helps reduce the size of needed dataset while getting amazing results. So stay tuned :)

### A deeper dive into GAN world

As mentioned earlier, we are going to build a GAN (a conditional GAN to be specific) and use an extra loss function, L1 loss. Let's start with the GAN.

As you might know, in a GAN we have a generator and a discriminator model which learn to solve a problem together. In our setting, the generator model takes a grayscale image (1-channel image) and produces a 2-channel image, a channel for \*a and another for \*b. The discriminator, takes these two produced channels and concatenates them with the input grayscale image and decides whether this new 3-channel image is fake or real. Of course the discriminator also needs to see some real images (3-channel images again in Lab color space) that are not produced by the generator and should learn that they are real.

So what about the "condition" we mentioned? Well, that grayscale image which both the generator and discriminator see is the condition that we provide to both models in our GAN and expect that the they take this condition into consideration.

Let's take a look at the math. Consider _**x**_ as the grayscale image, _**z**_ as the input noise for the generator, and _**y**_ as the 2-channel output we want from the generator (it can also represent the 2 color channels of a real image). Also, _**G**_ is the generator model and _**D**_ is the discriminator. Then the loss for our conditional GAN will be:

![GAN Loss](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/GAN_loss.jpg?raw=1)

Notice that _**x**_ is given to both models which is the condition we introduce two both players of this game. Actually, we are not going to feed a "n" dimensional vector of random noise to the generator as you might expect but the noise is introduced in the form of dropout layers (there is something cool about it which you will read in the last section of the article) in the generator architecture.

### Loss function we optimize

The earlier loss function helps to produce good-looking colorful images that seem real, but to further help the models and introduce some supervision in our task, we combine this loss function with L1 Loss (you might know L1 loss as mean absolute error) of the predicted colors compared with the actual colors:

![L1 loss](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/l1_loss.jpg?raw=1)

If we use L1 loss alone, the model still learns to colorize the images but it will be conservative and most of the time uses colors like "gray" or "brown" because when it doubts which color is the best, it takes the average and uses these colors to reduce the L1 loss as much as possible (it is similar to the blurring effect of L1 or L2 loss in super resolution task). Also, the L1 Loss is preferred over L2 loss (or mean squared error) because it reduces that effect of producing gray-ish images. So, our combined loss function will be:

![loss](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/loss.jpg?raw=1)

where _**λ**_ is a coefficient to balance the contribution of the two losses to the final loss (of course the discriminator loss does not involve the L1 loss).

Okay. I think it's enough for theory! Let's get our hands dirty with the code! In the following section, **I first introduce the code to implement the paper** and in the section after that, **I will introduce a better strategy to get really amazing results in one or two hours of training and without needing huge amount of data!**

## 1 - Implementing the paper - Our Baseline

### 1.1- Loading Image Paths

The paper uses the whole ImageNet dataset (with 1.3 million images!) but here I'm using only 8,000 images from COCO dataset for training which I had available on my device. So our training set size is 0.6% of what was used in the paper!
You can use almost any dataset for this task as far as it contains many different scenes and locations which you hope it will learn to colorize. You can use ImageNet for example but you will only need 8000 of its images for this project.
"""

import os  # 파일 및 디렉토리 조작을 위한 모듈
import glob  # 파일 목록을 얻기 위한 모듈
import time  # 시간 관련 모듈
import numpy as np  # 수학 및 배열 처리를 위한 모듈
from PIL import Image  # 이미지 처리를 위한 모듈
from pathlib import Path  # 파일 경로 다루기를 위한 모듈
from tqdm.notebook import tqdm  # 진행 상황을 시각화하기 위한 모듈
import matplotlib.pyplot as plt  # 그래픽 출력을 위한 모듈
from skimage.color import rgb2lab, lab2rgb  # 이미지 컬러 공간 변환을 위한 모듈

import torch  # PyTorch 라이브러리
from torch import nn, optim  # 신경망 및 최적화 관련 모듈
from torchvision import transforms  # 이미지 변환을 위한 모듈
from torchvision.utils import make_grid  # 그리드 형태로 이미지를 결합하는 함수
from torch.utils.data import Dataset, DataLoader  # 데이터 로딩을 위한 모듈

# CUDA가 사용 가능하면 GPU로, 그렇지 않으면 CPU로 설정
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Google Colab 환경에서 실행 중인지 여부를 확인하기 위한 변수
use_colab = None

"""### 1.1.x Preparing Colab for running the code

If you are opening this on **Google Colab** you can uncomment and run the following to install fastai. Almost all of the code in the tutorial is with **pure PyTorch**. We need fastai here only to download part of COCO dataset and in one other step in the second section of the tutorial.

Also make sure to set your runtime to **GPU** to be able to train the models much faster.
"""

# fastai 라이브러리의 버전 2.4를 설치하기 위한 명령어
!pip install fastai==2.4

"""The following will download about 20,000 images from COCO dataset. Notice that **we are going to use only 8000 of them** for training. Also you can use any other dataset like ImageNet as long as it contains various scenes and locations."""

# from fastai.data.external import untar_data, URLs
# coco_path = untar_data(URLs.COCO_SAMPLE)
# coco_path = str(coco_path) + "/train_sample"
# use_colab = True

# Google Colab에서 Google Drive를 마운트하는 코드

# 필요한 라이브러리를 가져옵니다.
from google.colab import drive

# Google Drive를 Colab에 마운트합니다.
drive.mount('/content/drive')

# 마운트 경로는 일반적으로 '/content/drive'로 설정됩니다.
# Google Drive의 루트 폴더는 '/content/drive/My Drive/'에 연결됩니다.

# # 필요한 라이브러리를 가져옵니다.
# import glob
# import numpy as np

# # Google Drive에서 이미지 파일들이 저장된 경로를 지정합니다.
# path = "/content/drive/MyDrive/songhae"

# # 지정된 경로에서 모든 JPG 파일들을 찾아 리스트로 반환합니다.
# paths = glob.glob(path + "/*.jpg")

# # 만약 지정된 경로에 JPG 파일이 없다면 ValueError를 발생시킵니다.
# if not paths:
#     raise ValueError("No JPG files found in the specified directory.")

# # 샘플 크기를 결정합니다. 최대 2000개의 파일을 대상으로 합니다.
# # paths 리스트의 길이에 따라서 샘플 크기를 조정합니다.
# sample_size = min(2000, len(paths))

# # 난수 발생기를 초기화하여 paths 리스트에서 무작위로 샘플을 선택합니다.
# np.random.seed(123)
# paths_subset = np.random.choice(paths, sample_size, replace=False)

# # 코드 실행 중간에 콘솔에 출력을 추가하여 현재 상태를 확인합니다.
# print("Number of items in paths:", len(paths))

# Google Colab 환경에서 코드가 실행 중인지 확인
if use_colab == True:
    path ="/content/drive/MyDrive/songhae"
else:
    path = "/content/drive/MyDrive/songhae"

# glob을 사용하여 지정된 디렉토리의 모든 JPEG 이미지 파일 경로 목록 가져오기
paths = glob.glob(path + "/*.jpeg")
# 재현성을 위해 난수 시드 설정
np.random.seed(123)
# 중복 없이 2000개의 경로를 무작위로 선택
paths_subset = np.random.choice(paths, 2000, replace=False)
# 0에서 1999까지의 인덱스를 무작위로 섞음
rand_idxs = np.random.permutation(2000)

train_idxs = rand_idxs[:1500]  # 처음 1500개의 인덱스를 훈련 세트로 선택
val_idxs = rand_idxs[1500:]    # 나머지 500개의 인덱스를 검증 세트로 선택
train_paths = paths_subset[train_idxs]      # 훈련 및 검증 세트에 해당하는 파일 경로를 선택
val_paths = paths_subset[val_idxs]
print(len(train_paths), len(val_paths))     # 훈련 세트와 검증 세트의 이미지 수 출력

# fastai 라이브러리의 vision 모듈에서 모든 것을 가져옵니다.
from fastai.vision.all import *

# 로컬 이미지 폴더의 경로를 지정합니다.
custom_dataset_path = Path('/content/drive/MyDrive/songhae')

# 이미지 파일을 가져오는 함수를 정의합니다.
def get_image_files_custom_path(path):
    return get_image_files(path)

# DataBlock을 생성합니다.
# - blocks: ImageBlock(이미지), CategoryBlock(카테고리)을 사용합니다.
# - get_items: 이미지 파일을 가져오는 함수를 지정합니다.
# - splitter: 데이터를 트레이닝셋과 밸리데이션셋으로 나누는 비율을 설정합니다.
# - get_y: 카테고리를 가져오는 함수를 지정합니다.
# - item_tfms: 이미지 크기를 조정하는 등의 아이템 전처리를 수행하는 함수를 지정합니다.
# - batch_tfms: 배치 전체에 적용되는 전처리를 수행하는 함수를 지정합니다.
dblock = DataBlock(blocks=(ImageBlock, CategoryBlock),
                   get_items=get_image_files_custom_path,
                   splitter=RandomSplitter(valid_pct=0.2, seed=42),
                   get_y=parent_label,
                   item_tfms=Resize(460),
                   batch_tfms=[*aug_transforms(size=224), Normalize.from_stats(*imagenet_stats)])

# 전체 데이터 수를 6816개로 변경합니다.
# 트레이닝셋과 밸리데이션셋을 8:2로 나눕니다.
dls = dblock.dataloaders(custom_dataset_path, num_workers=0)

# 생성된 데이터로더를 사용하여 이미지 배치를 시각화합니다.
dls.show_batch()

# Subplots를 생성하여 4x4의 그리드를 만듭니다. 각 subplot의 크기는 10x10입니다.
_, axes = plt.subplots(4, 4, figsize=(10, 10))

# train_paths에 있는 이미지 경로를 하나씩 가져와서 subplot에 시각화합니다.
# axes.flatten()을 사용하여 4x4 그리드의 각 subplot에 대한 iterator를 얻습니다.
for ax, img_path in zip(axes.flatten(), dls.train_ds.items):
    # 이미지를 열어서 subplot에 표시합니다.
    img = PILImage.create(img_path)
    img.show(ax=ax)

    # subplot의 축을 제거합니다.
    ax.axis("off")

"""Although we are using the same dataset and number of training samples, the exact 8000 images that you train your model on may vary (although we are seeding!) because the dataset here has only 20000 images with different ordering while I sampled 10000 images from the complete dataset.

### 1.2- Making Datasets and DataLoaders

I hope the code is self-explanatory. I'm resizing the images and flipping horizontally (flipping only if it is training set) and then I read an RGB image, convert it to Lab color space and separate the first (grayscale) channel and the color channels as my inputs and targets for the models  respectively. Then I'm making the data loaders.
"""

SIZE = 256

class ColorizationDataset(Dataset):
    def __init__(self, paths, split='train'):
        # 데이터셋이 트레이닝셋인 경우와 밸리데이션셋인 경우에 대한 전처리를 설정합니다.
        if split == 'train':
            self.transforms = transforms.Compose([
                transforms.Resize((SIZE, SIZE),  Image.BICUBIC),  # 이미지 크기 조정 및 보간법 설정
                transforms.RandomHorizontalFlip(),  # 약간의 데이터 증강 (랜덤 수평 뒤집기)
            ])
        elif split == 'val':
            self.transforms = transforms.Resize((SIZE, SIZE),  Image.BICUBIC)  # 이미지 크기 조정만 수행

        self.split = split
        self.size = SIZE
        self.paths = paths

    def __getitem__(self, idx):
        # 이미지 파일을 열어서 RGB로 변환합니다.
        img = Image.open(self.paths[idx]).convert("RGB")

        # 설정된 전처리를 수행합니다.
        img = self.transforms(img)

        # 이미지를 NumPy 배열로 변환합니다.
        img = np.array(img)

        # RGB 이미지를 L*a*b 색 공간으로 변환합니다.
        img_lab = rgb2lab(img).astype("float32")  # Converting RGB to L*a*b

        # PyTorch 텐서로 변환합니다.
        img_lab = transforms.ToTensor()(img_lab)

        # L 채널을 추출하고 값을 -1에서 1로 정규화합니다.
        L = img_lab[[0], ...] / 50. - 1.  # Between -1 and 1

        # a, b 채널을 추출하고 값을 -1에서 1로 정규화합니다.
        ab = img_lab[[1, 2], ...] / 110.  # Between -1 and 1

        return {'L': L, 'ab': ab}

    def __len__(self):
        return len(self.paths)

def make_dataloaders(batch_size=16, n_workers=4, pin_memory=True, **kwargs):
    # ColorizationDataset을 기반으로 하는 DataLoader를 생성하는 함수입니다.
    dataset = ColorizationDataset(**kwargs)
    dataloader = DataLoader(dataset, batch_size=batch_size, num_workers=n_workers,
                            pin_memory=pin_memory)
    return dataloader

train_paths = glob.glob("/content/drive/MyDrive/songhae/*.jpeg")
val_paths = glob.glob("/content/drive/MyDrive/songhae/*.jpeg")


# train_paths를 사용하여 트레이닝 데이터로더를 생성합니다.
train_dl = make_dataloaders(paths=train_paths, split='train')

# val_paths를 사용하여 밸리데이션 데이터로더를 생성합니다.
val_dl = make_dataloaders(paths=val_paths, split='val')

# 다음 반복(iteration)에서의 데이터를 가져와서 확인해봅니다.
data = next(iter(train_dl), None)

# 만약 에폭이 끝나면 None이 반환됩니다.
if data is not None:
    # 데이터로더에서 가져온 데이터의 L 채널과 ab 채널의 shape를 출력합니다.
    Ls, abs_ = data['L'], data['ab']
    print("L channel shape:", Ls.shape)
    print("ab channels shape:", abs_.shape)
else:
    print("End of epoch. Resetting the dataloader for the next epoch.")
    train_dl = make_dataloaders(paths=train_paths, split='train')

# make_dataloaders 함수를 사용하여 훈련 및 검증 데이터 로더 생성
train_dl = make_dataloaders(paths=train_paths, split='train')
val_dl = make_dataloaders(paths=val_paths, split='val')

# 훈련 데이터 로더에서 다음 배치를 가져와서 데이터 확인
data = next(iter(train_dl))
Ls, abs_ = data['L'], data['ab']

# 훈련 데이터의 L 및 ab 채널의 형태 출력
print(Ls.shape, abs_.shape)
# 훈련 및 검증 데이터 로더의 길이 출력
print(len(train_dl), len(val_dl))

"""### 1.3- Generator proposed by the paper

This one is a little complicated and needs explanation. This code implements a U-Net to be used as the generator of our GAN. The details of the code are out of the scope of this article but the important thing to understand is that it makes the U-Net from the middle part of it (down in the U shape) and adds down-sampling and up-sampling modules to the left and right of that middle module (respectively) at every iteration until it reaches the input module and output module. Look at the following image that I made from one of the images in the article to give you a better sense of what is happening in the code:

![unet](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/unet.png?raw=1)

The blue rectangles show the order in which the related modules are built with the code. The U-Net we will build has more layers than what is depicted in this image but it suffices to give you the idea. Also notice in the code that we are going 8 layers down, so if we start with a 256 by 256 image, in the middle of the U-Net we will get a 1 by 1 (256 / 2⁸) image and then it gets up-sampled to produce a  256 by 256 image (with two channels). This code snippet is really exciting and I highly recommend to play with it to fully grasp what every line of it is doing.
"""

#U-Net 아키텍처를 정의하는 PyTorch 모델.
#UnetBlock 클래스는 U-Net의 각 블록을 정의하고, Unet 클래스는 전체 U-Net 아키텍처를 정의


class UnetBlock(nn.Module):
    def __init__(self, nf, ni, submodule=None, input_c=None, dropout=False,
                 innermost=False, outermost=False):
        super().__init__()
        self.outermost = outermost
        if input_c is None: input_c = nf
        # 다운샘플링을 위한 컨볼루션 레이어 및 활성화 함수 정의
        downconv = nn.Conv2d(input_c, ni, kernel_size=4,
                             stride=2, padding=1, bias=False)
        downrelu = nn.LeakyReLU(0.2, True)
        downnorm = nn.BatchNorm2d(ni)
        # 업샘플링을 위한 활성화 함수 및 정규화 레이어 정의
        uprelu = nn.ReLU(True)
        upnorm = nn.BatchNorm2d(nf)

        if outermost:
            # 최외곽 블록인 경우 업샘플링 레이어에 Tanh 활성화 함수 사용
            upconv = nn.ConvTranspose2d(ni * 2, nf, kernel_size=4,
                                        stride=2, padding=1)
            down = [downconv]
            up = [uprelu, upconv, nn.Tanh()]
            model = down + [submodule] + up
        elif innermost:
            # 최내곽 블록인 경우 업샘플링 레이어에 bias를 사용하지 않는 컨볼루션 레이어 사용
            upconv = nn.ConvTranspose2d(ni, nf, kernel_size=4,
                                        stride=2, padding=1, bias=False)
            down = [downrelu, downconv]
            up = [uprelu, upconv, upnorm]
            model = down + up
        else:
            # 중간 블록인 경우 드롭아웃을 사용할 수 있는 경우 드롭아웃 레이어 추가
            upconv = nn.ConvTranspose2d(ni * 2, nf, kernel_size=4,
                                        stride=2, padding=1, bias=False)
            down = [downrelu, downconv, downnorm]
            up = [uprelu, upconv, upnorm]
            if dropout: up += [nn.Dropout(0.5)]
            model = down + [submodule] + up
        self.model = nn.Sequential(*model)

    def forward(self, x):
        if self.outermost:
            return self.model(x)
        else:
            return torch.cat([x, self.model(x)], 1)

class Unet(nn.Module):
    def __init__(self, input_c=1, output_c=2, n_down=8, num_filters=64):
        super().__init__()
        # 최내곽 블록 생성
        unet_block = UnetBlock(num_filters * 8, num_filters * 8, innermost=True)
        # 다운샘플링 블록 생성
        for _ in range(n_down - 5):
            unet_block = UnetBlock(num_filters * 8, num_filters * 8, submodule=unet_block, dropout=True)
        out_filters = num_filters * 8
        # 업샘플링 블록 생성
        for _ in range(3):
            unet_block = UnetBlock(out_filters // 2, out_filters, submodule=unet_block)
            out_filters //= 2
        # 최외곽 블록 생성
        self.model = UnetBlock(output_c, out_filters, input_c=input_c, submodule=unet_block, outermost=True)

    def forward(self, x):
        return self.model(x)

"""### 1.4- Discriminator

The architecture of our discriminator is rather straight forward. This code implements a model by stacking blocks of Conv-BatchNorm-LeackyReLU to decide whether the input image is fake or real. Notice that the first and last blocks do not use normalization and the last block has no activation function (it is embedded in the loss function we will use).
"""

#PatchGAN 스타일의 판별자 네트워크를 정의하는 PyTorch 모델입니다.
 #PatchDiscriminator 클래스는 판별자의 아키텍처를 정의하고, get_layers 메서드는 판별자에서 반복적으로 사용되는 레이어 블록을 생성

class PatchDiscriminator(nn.Module):
    def __init__(self, input_c, num_filters=64, n_down=3):
        super().__init__()

        # Discriminator 모델의 레이어를 정의합니다.
        model = [self.get_layers(input_c, num_filters, norm=False)]

        # 다운샘플링 레이어를 n_down 만큼 반복하여 추가합니다.
        model += [self.get_layers(num_filters * 2 ** i, num_filters * 2 ** (i + 1), s=1 if i == (n_down-1) else 2)
                  for i in range(n_down)]  # 'if' 문은 이 루프의 마지막 블록에 대해 stride 2를 사용하지 않도록 처리합니다.

        # 최종 레이어를 추가합니다.
        model += [self.get_layers(num_filters * 2 ** n_down, 1, s=1, norm=False, act=False)]
        # 마지막 레이어에서는 normalization과 activation을 사용하지 않도록 조절합니다.

        # Sequential을 사용하여 모델을 정의합니다.
        self.model = nn.Sequential(*model)

    def get_layers(self, ni, nf, k=4, s=2, p=1, norm=True, act=True):
        # 반복적인 레이어 블록을 생성하는 메서드를 정의합니다.
        layers = [nn.Conv2d(ni, nf, k, s, p, bias=not norm)]
        if norm: layers += [nn.BatchNorm2d(nf)]
        if act: layers += [nn.LeakyReLU(0.2, True)]
        return nn.Sequential(*layers)

    def forward(self, x):
        # 모델을 통과하여 forward 연산을 수행합니다.
        return self.model(x)

"""Let's take a look at its blocks:"""

#PatchGAN 스타일의 판별자 네트워크를 정의하는 클래스
#입력 채널 수는 3으로 지정됩니다.
#주어진 입력 채널 수(3)로 초기화된 PatchGAN 스타일의 판별자 네트워크를 생성하는 부분
PatchDiscriminator(3)

"""And its output shape:"""

#주어진 입력 크기(16개의 이미지 샘플, 각각의 이미지는 3개의 채널을 가진 256x256 크기)로 더미 입력을 생성하고,
#이를 판별자에 전달하여 출력의 크기를 확인

# 위에서 정의한 판별자 클래스를 인스턴스화합니다.
discriminator = PatchDiscriminator(3)

# 더미 입력 데이터를 생성합니다. (batch_size=16, 채널=3, 이미지 크기=256x256)
dummy_input = torch.randn(16, 3, 256, 256)

# 생성한 판별자에 더미 입력을 전달하여 출력을 얻습니다.
out = discriminator(dummy_input)

# 출력의 크기(shape)를 확인합니다.
print("Output Shape:", out.shape)

"""We are using a "Patch" Discriminator here. Okay, what is it?! In a vanilla discriminator, the model outputs one number (a scaler) which represents how much the model thinks the input (which is the whole image) is real (or fake). In a patch discriminator, the model outputs one number for every patch of say 70 by 70 pixels of the input image and for each of them decides whether it is fake or not separately. Using such a model for the task of colorization seems reasonable to me because the local changes that the model needs to make are really important and maybe deciding on the whole image as in vanilla discriminator cannot take care of the subtleties of this task. Here, the model's output shape is 30 by 30 but it does not mean that our patches are 30 by 30. The actual patch size is obtained when you compute the receptive field of each of these 900 (30 multiplied by 30) output numbers which in our case will be 70 by 70.

### 1.5- GAN Loss

This is a handy class we can use to calculate the GAN loss of our final model. In the __init__ we decide which kind of loss we're going to use (which will be "vanilla" in our project) and register some constant tensors as the "real" and "fake" labels. Then when we call this module, it makes an appropriate tensor full of zeros or ones (according to what we need at the stage) and computes the loss.
"""

class GANLoss(nn.Module):
    def __init__(self, gan_mode='vanilla', real_label=1.0, fake_label=0.0):
        super().__init__()
        # 실제 및 가짜 레이블을 버퍼로 등록
        self.register_buffer('real_label', torch.tensor(real_label))
        self.register_buffer('fake_label', torch.tensor(fake_label))
        # GAN 모드에 따라 손실 함수 선택
        if gan_mode == 'vanilla':
            self.loss = nn.BCEWithLogitsLoss()
        elif gan_mode == 'lsgan':
            self.loss = nn.MSELoss()

    def get_labels(self, preds, target_is_real):
        # 타겟이 실제인 경우 실제 레이블을, 가짜인 경우 가짜 레이블을 반환
        if target_is_real:
            labels = self.real_label
        else:
            labels = self.fake_label
        return labels.expand_as(preds)

    def __call__(self, preds, target_is_real):
        # 예측값과 타겟에 따라 손실 계산
        labels = self.get_labels(preds, target_is_real)
        loss = self.loss(preds, labels)
        return loss

"""### 1.x Model Initialization

In the TowardsDataScince article, I didn't explain this function. Here is our logic to initialize our models. We are going to initialize the weights of our model with a mean of 0.0 and standard deviation of 0.02 which are the proposed hyperparameters in the article:
"""

def init_weights(net, init='norm', gain=0.02):
    """
    네트워크의 가중치를 초기화하는 함수.

    Parameters:
        net (nn.Module): 초기화할 네트워크 모델
        init (str): 가중치 초기화 방법. 'norm', 'xavier', 'kaiming' 중 하나 선택
        gain (float): 초기화 스케일

    Returns:
        nn.Module: 초기화된 네트워크 모델
    """

    def init_func(m):
        classname = m.__class__.__name__
        if hasattr(m, 'weight') and 'Conv' in classname:
            # Convolutional 레이어의 가중치 초기화
            if init == 'norm':
                nn.init.normal_(m.weight.data, mean=0.0, std=gain)
            elif init == 'xavier':
                nn.init.xavier_normal_(m.weight.data, gain=gain)
            elif init == 'kaiming':
                nn.init.kaiming_normal_(m.weight.data, a=0, mode='fan_in')

            if hasattr(m, 'bias') and m.bias is not None:
                # Convolutional 레이어의 편향 초기화
                nn.init.constant_(m.bias.data, 0.0)
        elif 'BatchNorm2d' in classname:
            # BatchNorm2d 레이어의 가중치 및 편향 초기화
            nn.init.normal_(m.weight.data, 1., gain)
            nn.init.constant_(m.bias.data, 0.)

    # 네트워크에 초기화 함수를 적용
    net.apply(init_func)
    print(f"model initialized with {init} initialization")
    return net

def init_model(model, device):
   """
    모델을 지정된 디바이스로 이동하고 가중치를 초기화하는 함수.

    Parameters:
        model (nn.Module): 초기화 및 디바이스 이동할 모델
        device (torch.device): 모델을 이동할 디바이스

    Returns:
        nn.Module: 초기화 및 디바이스 이동된 모델
    """
    model = model.to(device)
    model = init_weights(model)
    return model

"""### 1.6- Putting everything together

This class brings together all the previous parts and implements a few methods to take care of training our complete model. Let's investigate it.

In the __init__ we define our generator and discriminator using the previous functions and classes we defined and we also initialize them with init_model function which I didn't explain here but you can refer to my GitHub repository to see how it works. Then we define our two loss functions and the optimizers of the generator and discriminator.

The whole work is being done in optimize method of this class. First and only once per iteration (batch of training set) we call the module's forward method and store the outputs in fake_color variable of the class.

Then, we first train the discriminator by using backward_D method in which we feed the fake images produced by generator to the discriminator (make sure to detach them from the generator's graph so that they act as a constant to the discriminator, like normal images) and label them as fake. Then we feed a batch of real images from training set to the discriminator and label them as real. We add up the two losses for fake and real and take the average and then call the backward on the final loss.
Now, we can train the generator. In backward_G method we feed the discriminator the fake image and try to fool it by assigning real labels to them and calculating the adversarial loss. As I mentioned earlier, we use L1 loss as well and compute the distance between the predicted two channels and the target two channels and multiply this loss by a coefficient (which is 100 in our case) to balance the two losses and then add this loss to the adversarial loss. Then we call the backward method of the loss.
"""

class MainModel(nn.Module):
    def __init__(self, net_G=None, lr_G=2e-4, lr_D=2e-4,
                 beta1=0.5, beta2=0.999, lambda_L1=100.):
        super().__init__()

        # GPU 사용 가능한 경우 "cuda", 그렇지 않은 경우 "cpu"로 디바이스 설정
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.lambda_L1 = lambda_L1

        # Generator 네트워크 초기화
        if net_G is None:
            self.net_G = init_model(Unet(input_c=1, output_c=2, n_down=8, num_filters=64), self.device)
        else:
            self.net_G = net_G.to(self.device)

        # Discriminator 네트워크 초기화
        self.net_D = init_model(PatchDiscriminator(input_c=3, n_down=3, num_filters=64), self.device)

        # GAN 및 L1 손실 함수 초기화
        self.GANcriterion = GANLoss(gan_mode='vanilla').to(self.device)
        self.L1criterion = nn.L1Loss()

        # Generator 및 Discriminator의 옵티마이저 초기화
        self.opt_G = optim.Adam(self.net_G.parameters(), lr=lr_G, betas=(beta1, beta2))
        self.opt_D = optim.Adam(self.net_D.parameters(), lr=lr_D, betas=(beta1, beta2))

    def set_requires_grad(self, model, requires_grad=True):
        for p in model.parameters():
            p.requires_grad = requires_grad

    def setup_input(self, data):
        # 입력 데이터를 디바이스로 이동
        self.L = data['L'].to(self.device)
        self.ab = data['ab'].to(self.device)

    def forward(self):
        # Generator에 입력을 전달하여 가짜 색상 생성
        self.fake_color = self.net_G(self.L)

    def backward_D(self):
        # 가짜 이미지와 실제 이미지를 합쳐서 Discriminator에 전달
        fake_image = torch.cat([self.L, self.fake_color], dim=1)
        fake_preds = self.net_D(fake_image.detach())
        self.loss_D_fake = self.GANcriterion(fake_preds, False)

        real_image = torch.cat([self.L, self.ab], dim=1)
        real_preds = self.net_D(real_image)
        self.loss_D_real = self.GANcriterion(real_preds, True)

        # Discriminator의 총 손실 계산
        self.loss_D = (self.loss_D_fake + self.loss_D_real) * 0.5
        self.loss_D.backward()

    def backward_G(self):
        # 가짜 이미지와 해당 실제 색상 사이의 GAN 및 L1 손실 계산
        fake_image = torch.cat([self.L, self.fake_color], dim=1)
        fake_preds = self.net_D(fake_image)
        self.loss_G_GAN = self.GANcriterion(fake_preds, True)
        self.loss_G_L1 = self.L1criterion(self.fake_color, self.ab) * self.lambda_L1

        # Generator의 총 손실 계산
        self.loss_G = self.loss_G_GAN + self.loss_G_L1
        self.loss_G.backward()

    def optimize(self):
        # 순전파 수행
        self.forward()

        # Discriminator를 학습 모드로 전환하고 그래디언트 초기화
        self.net_D.train()
        self.set_requires_grad(self.net_D, True)
        self.opt_D.zero_grad()

        # Discriminator 역전파 및 옵티마이즈
        self.backward_D()
        self.opt_D.step()

        # Generator를 학습 모드로 전환하고 Discriminator의 그래디언트 비활성화
        self.net_G.train()
        self.set_requires_grad(self.net_D, False)
        self.opt_G.zero_grad()

        # Generator 역전파 및 옵티마이즈
        self.backward_G()
        self.opt_G.step()

"""### 1.xx Utility functions

These functions were nor included in the explanations of the TDS article. These are just some utility functions to log the losses of our network and also visualize the results during training. So here you can check them out:
"""

#AverageMeter 클래스와 관련된 함수들, 손실 업데이트 및 시각화, 손실 로깅을 수행하는 함수들을 정의

class AverageMeter:
    def __init__(self):
        self.reset()

    def reset(self):
        # 누적된 count, 평균, 합을 초기화하는 메서드
        self.count, self.avg, self.sum = [0.] * 3

    def update(self, val, count=1):
        # 새로운 값(val)을 받아서 count만큼 더하고 sum에 누적하여 평균을 갱신하는 메서드
        self.count += count
        self.sum += count * val
        self.avg = self.sum / self.count

def create_loss_meters():
    # 손실값을 저장할 AverageMeter 인스턴스를 생성하는 함수
    loss_D_fake = AverageMeter()
    loss_D_real = AverageMeter()
    loss_D = AverageMeter()
    loss_G_GAN = AverageMeter()
    loss_G_L1 = AverageMeter()
    loss_G = AverageMeter()

    return {'loss_D_fake': loss_D_fake,
            'loss_D_real': loss_D_real,
            'loss_D': loss_D,
            'loss_G_GAN': loss_G_GAN,
            'loss_G_L1': loss_G_L1,
            'loss_G': loss_G}

def update_losses(model, loss_meter_dict, count):
    # 모델의 손실값을 받아서 AverageMeter를 업데이트하는 함수
    for loss_name, loss_meter in loss_meter_dict.items():
        loss = getattr(model, loss_name)
        loss_meter.update(loss.item(), count=count)

def lab_to_rgb(L, ab):
    """
    주어진 Lab 이미지를 RGB로 변환하는 함수

    Parameters:
        L (torch.Tensor): L 채널 이미지
        ab (torch.Tensor): ab 채널 이미지

    Returns:
        np.ndarray: RGB 이미지 배열
    """

    # L, ab 채널을 원래의 값 범위로 변환
    L = (L + 1.) * 50.
    ab = ab * 110.
    # Lab 이미지를 RGB 이미지로 변환하여 numpy 배열로 반환
    Lab = torch.cat([L, ab], dim=1).permute(0, 2, 3, 1).cpu().numpy()
    rgb_imgs = []
    for img in Lab:
        img_rgb = lab2rgb(img)
        rgb_imgs.append(img_rgb)
    return np.stack(rgb_imgs, axis=0)

def visualize(model, data, save=True):
    # 모델을 평가 모드로 설정하고 입력 데이터를 이용하여 가짜 및 실제 색상 생성
    model.net_G.eval()
    with torch.no_grad():
        model.setup_input(data)
        model.forward()
    model.net_G.train()
    fake_color = model.fake_color.detach()
    real_color = model.ab
    L = model.L
    # Lab 이미지를 RGB 이미지로 변환
    fake_imgs = lab_to_rgb(L, fake_color)
    real_imgs = lab_to_rgb(L, real_color)
    # 결과 시각화를 위한 그림 생성
    fig = plt.figure(figsize=(15, 8))
    for i in range(5):
        # L 채널 시각화
        ax = plt.subplot(3, 5, i + 1)
        ax.imshow(L[i][0].cpu(), cmap='gray')
        ax.axis("off")
        # 가짜 색상 시각화
        ax = plt.subplot(3, 5, i + 1 + 5)
        ax.imshow(fake_imgs[i])
        ax.axis("off")
        # 실제 색상 시각화
        ax = plt.subplot(3, 5, i + 1 + 10)
        ax.imshow(real_imgs[i])
        ax.axis("off")
    plt.show()
    # 그림 저장 옵션
    if save:
        fig.savefig(f"colorization_{time.time()}.png")

def log_results(loss_meter_dict):
    # AverageMeter에 저장된 평균 손실값을 출력하는 함수
    for loss_name, loss_meter in loss_meter_dict.items():
        print(f"{loss_name}: {loss_meter.avg:.5f}")

"""1.7- Training function

I hope this code is self-explanatory. Every epoch takes about 4 minutes on not a powerful GPU as Nvidia P5000. So if you are using 1080Ti or higher, it will be much faster.
"""

import time
# 시작 시간 기록
start_time = time.time()
# 여기에 실행하고자 하는 코드 작성

def train_model(model, train_dl, epochs, display_every=200):
    data = next(iter(val_dl)) # getting a batch for visualizing the model output after fixed intrvals
    for e in range(epochs):
        loss_meter_dict = create_loss_meters() # function returing a dictionary of objects to
        i = 0                                  # log the losses of the complete network
        for data in tqdm(train_dl):
            model.setup_input(data)
            model.optimize()
            update_losses(model, loss_meter_dict, count=data['L'].size(0)) # function updating the log objects
            i += 1
            if i % display_every == 0:
                print(f"\nEpoch {e+1}/{epochs}")
                print(f"Iteration {i}/{len(train_dl)}")
                log_results(loss_meter_dict) # function to print out the losses
                visualize(model, data, save=False) # function displaying the model's outputs

model = MainModel()
train_model(model, train_dl, 1)

# 종료 시간 기록
end_time = time.time()
# 실행 시간 계산 (종료 시간 - 시작 시간)
elapsed_time = end_time - start_time
# 실행 시간을 시, 분, 초로 변환
hours, remainder = divmod(elapsed_time, 3600)
minutes, seconds = divmod(remainder, 60)
# 결과 출력
print(f"실행 시간: {int(hours)}시간 {int(minutes)}분 {int(seconds)}초")### 1.7- Training function

# #주어진 에폭 동안 모델을 학습하고, 일정한 간격으로 손실을 출력하고 모델의 출력을 시각화하는 훈련 함수

# def train_model(model, train_dl, epochs, display_every=200):
#     """
#     모델을 학습하는 함수.

#     Args:
#         model: 학습할 모델.
#         train_dl: 학습 데이터로 구성된 데이터로더.
#         epochs (int): 학습할 에폭 수.
#         display_every (int): 일정 iteration 마다 결과를 표시할 빈도. 기본값은 200.
#     """
#     data = next(iter(val_dl)) # 고정된 간격으로 모델 출력을 시각화하기 위해 배치를 가져옵니다.
#     for e in range(epochs):
#         loss_meter_dict = create_loss_meters() # 네트워크의 손실을 기록할 물체들을 생성하는 함수
#         i = 0                                  # 전체 네트워크의 손실을 기록하기 위한 딕셔너리를 초기화합니다.
#         for data in tqdm(train_dl):
#             model.setup_input(data)
#             model.optimize()
#             update_losses(model, loss_meter_dict, count=data['L'].size(0)) # 손실을 업데이트하는 함수
#             i += 1
#             if i % display_every == 0:
#                 print(f"\nEpoch {e+1}/{epochs}")
#                 print(f"Iteration {i}/{len(train_dl)}")
#                 log_results(loss_meter_dict) # 손실을 출력하는 함수
#                 visualize(model, data, save=False) # 모델의 출력을 표시하는 함수

# model = MainModel()
# train_model(model, train_dl, epochs=100)

"""Every epoch takes about 3 to 4 minutes on Colab. After about 20 epochs you should see some reasonable results.

Okay. I let the model train for some longer (about 100 epochs). Here are the results of our baseline model:

![baseline](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/baseline.png?raw=1)

As you can see, although this baseline model has some basic understanding of some most common objects in images like sky, trees, … its output is far from something appealing and it cannot decide on the color of rare objects. It also displays some color spillovers and circle-shaped mass of color (center of first image of second row) which is not good at all. So, it seems like that with this small dataset we cannot get good results with this strategy. **Therefore, we change our strategy!**

## 2- A new strategy - the final model

Here is the focus of this article and where I'm going to explain what I did to overcome the last mentioned problem. Inspired by an idea in Super Resolution literature, I decided to pretrain the generator separately in a supervised and deterministic manner to avoid the problem of "the blind leading the blind" in the GAN game where neither generator nor discriminator knows anything about the task at the beginning of training.

Actually I use pretraining in two stages: 1- The backbone of the generator (the down sampling path) is a pretrained model for classification (on ImageNet) 2- The whole generator will be pretrained on the task of colorization with L1 loss.

In fact, I'm going to use a pretrained ResNet18 as the backbone of my U-Net and to accomplish the second stage of pretraining, we are going to train the U-Net on our training set with only L1 Loss. Then we will move to the combined adversarial and L1 loss, as we did in the previous section.

### 2.1- Using a new generator

Building a U-Net with a ResNet backbone is not something trivial so I'll use fastai library's Dynamic U-Net module to easily build one. You can simply install fastai with pip or conda (if you haven't already at the beginning of the tutorial). Here's the link to the [documentation](https://docs.fast.ai/).

#### Update Jan 8th, 2022: <br>
You need to install fastai version 2.4 for the following lines code to run w/o errors.
If you have already installed it using the cell in the beginning of the tutorial, you don't need to install it here again.
<br><br><br>
"""

# fastai 라이브러리의 버전 2.4를 설치합니다.
# fastai 라이브러리는 딥러닝 작업을 간편하게 수행할 수 있는 도구를 제공합니다.
!pip install fastai==2.4

# fastai.vision 패키지에서 create_body 함수와 resnet18 모델을 가져옵니다.
from fastai.vision.learner import create_body
from torchvision.models.resnet import resnet18

# fastai.vision.models 패키지에서 DynamicUnet 클래스를 가져옵니다.
from fastai.vision.models.unet import DynamicUnet

#ResNet18 기반의 U-Net 모델을 생성하는 역할

def build_res_unet(n_input=1, n_output=2, size=256):
    """
    ResNet18 기반의 U-Net 모델을 생성하는 함수.

    Args:
        n_input (int): 입력 채널 수. 기본값은 1.
        n_output (int): 출력 채널 수. 기본값은 2.
        size (int): 이미지 크기. 기본값은 256.

    Returns:
        nn.Module: ResNet18 기반의 U-Net 모델.
    """
    # 현재 사용 가능한 디바이스 확인
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    # ResNet18의 바디 부분을 가져와서 생성
    body = create_body(resnet18, pretrained=True, n_in=n_input, cut=-2)

    # U-Net 모델 생성
    net_G = DynamicUnet(body, n_output, (size, size)).to(device)

    return net_G

"""That's it! With just these few lines of code you can build such a complex model easily. create_body function loads the pretrained weights of the ResNet18 architecture and cuts the model to remove the last two layers (GlobalAveragePooling and a Linear layer for the ImageNet classification task). Then, DynamicUnet uses this backbone to build a U-Net with the needed output channels (2 in our case) and with an input size of 256.

### 2.2 Pretraining the generator for colorization task
"""

#생성자를 사전 훈련하는 함수
#주어진 모델, 최적화기, 손실 함수 및 에폭 수로 생성자를 사전 훈련하고, 결과를 저장하는 부분

def pretrain_generator(net_G, train_dl, opt, criterion, epochs):
    """
    생성자(generator)를 사전 훈련하는 함수.

    Args:
        net_G: 사전 훈련할 생성자 모델.
        train_dl: 훈련 데이터로 구성된 데이터로더.
        opt: 최적화기(optimizer).
        criterion: 손실 함수.
        epochs (int): 훈련할 에폭 수.
    """
    for e in range(epochs):
        loss_meter = AverageMeter()
        for data in tqdm(train_dl):
            # 데이터를 GPU로 이동
            L, ab = data['L'].to(device), data['ab'].to(device)

            # 생성자에 입력을 전달하여 예측을 수행
            preds = net_G(L)

            # 손실 계산 및 역전파
            loss = criterion(preds, ab)
            opt.zero_grad()
            loss.backward()
            opt.step()

            # 손실 미터 업데이트
            loss_meter.update(loss.item(), L.size(0))

        # 에폭마다 손실 출력
        print(f"Epoch {e + 1}/{epochs}")
        print(f"L1 Loss: {loss_meter.avg:.5f}")

# 모델 생성
net_G = build_res_unet(n_input=1, n_output=2, size=256)
opt = optim.Adam(net_G.parameters(), lr=1e-4)
criterion = nn.L1Loss()

# 생성자 사전 훈련
pretrain_generator(net_G, train_dl, opt, criterion, epochs=20)

# 모델 저장
# torch.save(net_G.state_dict(), "res18-unet.pt")

"""With this simple function, we pretrain the generator for 20 epochs and then we save its weights. This will take an hour on Colab. In the following section, we will use this model as the generator for our GAN and train the whole network as before:

### 2.3 Putting everything together, again!

If you want to train the model yourself, run the following cell. Instead, if you want to use the pretrained weights, skip the cell and run the one after that.
"""

#주어진 생성자 모델을 불러와 MainModel에 전달하고, 주어진 데이터로 모델을 학습하는 과정

# 생성자 모델을 구축합니다.
net_G = build_res_unet(n_input=1, n_output=2, size=256)

# 미리 훈련된 생성자 모델의 가중치를 로드합니다.
net_G.load_state_dict(torch.load("/content/drive/MyDrive/songhae/res18-unet.pth", map_location=device))

# MainModel 클래스의 인스턴스를 생성하고 미리 훈련된 생성자 모델을 전달합니다.
model = MainModel(net_G=net_G)

# 주어진 모델과 훈련 데이터로 train_model 함수를 사용하여 학습을 수행합니다.
# 주어진 에폭 수는 20입니다.
train_model(model, train_dl, epochs=20)

"""Here I'm first loading the saved weights for the generator (which you have saved in the previous section) and then I'm using this model as the generator in our MainModel class  which prevents it from randomly initializing the generator. Then we train the model for 10 to 20 epochs! (compare it to the 100 epochs of the previous section when we didn't use pretraining). Each epoch takes about 3 to 4 minutes on Colab

If you are on Colab and want to use the pretrained weights, run the following cells which download the weights from my google drive and loads it to the model:
"""

# gdown은 Google Drive에서 파일을 다운로드하기 위한 명령입니다.
# --id 플래그 다음에는 Google Drive에서 파일을 식별하는 고유 ID가 있습니다.
# 지정된 ID를 사용하여 Google Drive에서 파일을 가져와 로컬 디렉토리에 저장합니다.

# 아래 명령어는 지정된 Google Drive 파일 ID로부터 파일을 다운로드합니다.
!gdown --id 1lR6DcS4m5InSbZ5y59zkH2mHt_4RQ2KV

# PyTorch의 torch.save 함수를 사용하여 모델의 상태 사전(state_dict)을 저장하는 코드입니다.
# model.state_dict()는 모델의 가중치와 매개변수를 포함하는 사전을 반환합니다.

# 저장된 파일 경로는 "/content/drive/MyDrive/songhae/final_model_weights.pt"로 지정되었습니다.
# 이 위치에 모델의 가중치가 저장됩니다.

# 모델의 학습된 가중치를 나중에 재사용하거나 다른 시스템에서 모델을 로드하여 사용할 때 유용합니다.
torch.save(model.state_dict(), "/content/drive/MyDrive/songhae/final_model_weights.pt")

net_G = build_res_unet(n_input=1, n_output=2, size=256)
net_G.load_state_dict(torch.load("/content/drive/MyDrive/songhae/res18-unet.pth", map_location=device))
model = MainModel(net_G=net_G)
model.load_state_dict(torch.load("/content/drive/MyDrive/songhae/final_model_weights.pt", map_location=device))

"""Now, I will show the results of this final model on the test set (the black and white images that it has never seen during training) including the main title image of this article at the very beginning:

![output 1](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/main.png?raw=1)
Left: Input black & white images from test set | Right: the colorized outputs by the final model of this tutorial
---
![output2](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/img1.png?raw=1)
Left: Input black & white images from test set | Right: the colorized outputs by the final model of this tutorial
---
![output3](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/img2.png?raw=1)
Left: Input black & white images from test set | Right: the colorized outputs by the final model of this tutorial
---

## An accidental finding: You can safely remove Dropout!

Remember that when I was explaining the theory of conditional GAN in the beginning of this article, I said that the source of the noise in the architecture of the generator proposed by authors of the paper was the dropout layers. However, when I investigated the U-Net we built with the help of fastai, I did not find any dropout layers in there! Actually I first trained the final model and got the results and then I investigated the generator and found this out.

So, was the adversarial training useless? If there is no noise, how possibly the generator can have a creative effect on the output? Is it possible that the input grayscale image to the generator plays the role of noise as well? These were my exact questions at the time.

Therefor, I decided to email Dr. Phillip Isola, the first author of the same paper we implemented here, and he kindly answered these questions. According to what he said,  this conditional GAN can still work without dropout but the outputs will be more deterministic because of the lack of that noise; however, there is still enough information in that input grayscale image which enables the generator to produce compelling outputs.
Actually, I saw this in practice that the adversarial training was helpful indeed. In the next and last section, I'm going to compare the results of the pretrained U-Net with no adversarial training against the final outputs we got with adversarial training.

## Comparing the results of the pretrained U-Net with and without adversarial training

One of the cool thing I found in my experiments was that the U-Net we built with the ResNet18 backbone is already awesome in colorizing images after pretraining with L1 Loss only (a step before the final adversarial training). But, the model is still conservative and encourages using gray-ish colors when it is not sure about what the object is or what color it should be. However, it performs really awesome for common scenes in the images like sky, tree, grass, etc.

Here I show you the outputs of the U-Net without adversarial training and U-Net with adversarial training to better depict the significant difference that the adversarial training is making in our case:

![comparison](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/comparison1.png?raw=1)
(Left: pretrained U-Net without adversarial training | Right: pretrained U-Net with adversarial training)
---

You can also see the GIF below to observe the difference between the images better:

![anim](https://github.com/moein-shariatnia/Deep-Learning/blob/main/Image%20Colorization%20Tutorial/files/anim_compare.gif?raw=1)
(animation of the last two images to better see the significant difference that adversarial training is making)
---

## Final words

This project was full of important lessons for myself. I spent a lot of time during the last month to implement lots of different papers each with different strategies and it took quite a while and after A LOT of failures that I could come up with this method of training. Now you can see that how pretraining the generator significantly helped the model and improved the results.

I also learned that some observations, although at first feeling like a bad mistake of yours, are worth paying attention to and further investigation; like the case of dropout in this project. Thanks to the helpful community of deep learning and AI, you can easily ask experts and get the answer you need and become more confidant in what you were just guessing.

I want to thank the authors of this wonderful paper for their awesome work and also [the great GitHub repository of this paper](https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix) from which I borrowed some of the codes (with modification and simplification). I truly love the community of computer science and AI and all their hard work to improve the field and also make their contributions available to all. I'm happy to be a tiny part of this community.
"""